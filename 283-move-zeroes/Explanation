# Move Zeroes

The problem is to move all the zeros in a given integer array to the end of the array while maintaining the relative order of the non-zero elements. The operation should rearrange the elements so that all non-zero values appear first, followed by all zeros.

For example, if the input array is `[0, 1, 0, 3, 12]`, the expected output is `[1, 3, 12, 0, 0]`.

The intuition behind this solution is straightforward. We iterate through the array and copy all non-zero elements into a new array in the same order in which they appear. Since the new array is initialized with zeros, the remaining positions automatically remain zero. Finally, we assign the new array back to the original one.

This approach prioritizes clarity and simplicity over in-place optimization.

The algorithm works as follows. We initialize a new array `ans` of the same size as the input array and fill it with zeros. We then iterate through the original array and whenever we encounter a non-zero element, we place it at the next available position in the new array. A pointer `j` keeps track of where the next non-zero element should be placed.

Pseudocode:
Initialize j = 0  
Create an array ans of size n filled with 0  
For i from 0 to n - 1  
If nums[i] is not 0  
Set ans[j] = nums[i]  
Increment j  
Assign ans back to nums  

Dry Run:

Input:
nums = [0, 1, 0, 3, 12]

Step-by-step execution:
- Start with ans = [0, 0, 0, 0, 0], j = 0  
- i = 0 → nums[i] = 0 → skip  
- i = 1 → nums[i] = 1 → ans = [1, 0, 0, 0, 0], j = 1  
- i = 2 → nums[i] = 0 → skip  
- i = 3 → nums[i] = 3 → ans = [1, 3, 0, 0, 0], j = 2  
- i = 4 → nums[i] = 12 → ans = [1, 3, 12, 0, 0], j = 3  

Final Output:
[1, 3, 12, 0, 0]

Time Complexity:
The time complexity is O(n) because the array is traversed once.

Space Complexity:
The space complexity is O(n) due to the extra array used.

This solution is easy to understand and works well when extra space usage is allowed. An in-place solution can further optimize space usage.


# Next Greater Element I

The problem is to find the next greater element for each element in `nums1` based on its position in `nums2`. The next greater element of a number is the first element to its right in `nums2` that is greater than it. If no such element exists, the answer should be `-1`.

Both arrays contain unique elements, and `nums1` is a subset of `nums2`.

Example:
nums1 = [4, 1, 2]  
nums2 = [1, 3, 4, 2]  
Output = [-1, 3, -1]

---

### Intuition

A brute-force approach would be to, for each element in `nums1`, search to the right in `nums2` to find the next greater element. However, this would be inefficient.

Instead, we preprocess `nums2` using a **monotonic decreasing stack**. The idea is to traverse `nums2` from right to left and maintain a stack that keeps elements in decreasing order. For each element:
- We remove all smaller elements from the stack because they can never be the next greater element.
- The element remaining on top of the stack (if any) is the next greater element.
- We store this mapping in a hash map.

Once this preprocessing is done, we can quickly answer queries for `nums1` using the map.

---

### Pseudocode

- Create an empty stack
- Create an empty hash map
- Traverse nums2 from right to left:
  - While stack is not empty and top < current element, pop
  - If stack is not empty, map current element to stack top
  - Push current element onto the stack
- For each element in nums1:
  - If it exists in the map, add mapped value to result
  - Otherwise, add -1
- Return result

---

### Dry Run

Input:
nums1 = [4, 1, 2]
nums2 = [1, 3, 4, 2]

Processing nums2 from right to left:

- Start with empty stack
- i = 3 → value = 2  
  Stack empty → push 2  
  Stack: [2]

- i = 2 → value = 4  
  Pop 2 (2 < 4)  
  Stack empty → no next greater  
  Push 4  
  Stack: [4]

- i = 1 → value = 3  
  Top = 4 (> 3) → next greater is 4  
  Map: 3 → 4  
  Push 3  
  Stack: [4, 3]

- i = 0 → value = 1  
  Top = 3 (> 1) → next greater is 3  
  Map: 1 → 3  
  Push 1  
  Stack: [4, 3, 1]

Now build result for nums1:

- 4 → not in map → -1  
- 1 → map gives 3  
- 2 → not in map → -1  

Final Output:
[-1, 3, -1]

---

### Time and Space Complexity

- **Time Complexity:** O(n + m), where n is size of nums2 and m is size of nums1
- **Space Complexity:** O(n) due to stack and hash map

---

### Conclusion

Using a monotonic stack allows us to efficiently preprocess the next greater elements in a single pass. This approach avoids redundant comparisons and is widely used in stack-based array problems.

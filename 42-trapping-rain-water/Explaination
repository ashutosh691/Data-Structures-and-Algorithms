# Trapping Rain Water

The problem is to calculate how much rainwater can be trapped between bars of different heights after raining. You are given an array `height` where each element represents the height of a bar, and the width of each bar is 1. The goal is to compute the total amount of water that can be trapped between these bars.

For example, for the array `[0,1,0,2,1,0,1,3,2,1,2,1]`, the total trapped water is `6`.

The intuition behind this solution is based on the fact that the amount of water trapped at any index depends on the **maximum height to its left** and the **maximum height to its right**. The water trapped at a position is:

min(maxLeft, maxRight) − height[i]

To compute this efficiently, we use a **two-pointer approach**. One pointer starts from the left end and the other from the right end of the array. We maintain two variables:
- `l` to store the maximum height seen so far from the left
- `r` to store the maximum height seen so far from the right

At each step, we compare the heights at the two pointers:
- If the left height is smaller, then water trapped depends on the left maximum
- Otherwise, it depends on the right maximum

This works because the smaller side always limits the water level.

Pseudocode:
- Initialize two pointers `i = 0` and `j = n − 1`
- Initialize `l = height[0]`, `r = height[n − 1]`
- Initialize `ans = 0`
- While `i < j`:
  - Update `l = max(l, height[i])`
  - Update `r = max(r, height[j])`
  - If `height[i] < height[j]`:
    - Add `l − height[i]` to answer
    - Move `i` to the right
  - Else:
    - Add `r − height[j]` to answer
    - Move `j` to the left
- Return `ans`

Dry Run:

Input:
height = [4,2,0,3,2,5]

Step-by-step execution:

- i = 0, j = 5  
  l = 4, r = 5 → height[i] < height[j]  
  water += 4 − 4 = 0  

- i = 1  
  l = 4 → water += 4 − 2 = 2  

- i = 2  
  l = 4 → water += 4 − 0 = 4  

- i = 3  
  l = 4 → water += 4 − 3 = 1  

- i = 4  
  l = 4 → water += 4 − 2 = 2  

Total trapped water:
0 + 2 + 4 + 1 + 2 = 9

Final Output:
9

Time Complexity:
The algorithm runs in O(n) time because each element is processed once using two pointers.

Space Complexity:
The space complexity is O(1) since only a constant amount of extra space is used.

This two-pointer method is optimal, efficient, and commonly used in interview problems involving prefix and suffix maximums.

# Kth Largest Element in an Array

The problem is to find the kth largest element in an unsorted array of integers. The array may contain duplicate values, and the kth largest element refers to the kth position in the sorted order (not the kth distinct element).

For example, given the array [3, 2, 1, 5, 6, 4] and k = 2, the sorted order is [6, 5, 4, 3, 2, 1], so the 2nd largest element is 5.

The intuition behind this solution is to use a **min-heap of size k**. Instead of sorting the entire array, we only keep track of the k largest elements seen so far. A min-heap is ideal here because the smallest element among the k largest elements will always be at the top. Whenever the heap size exceeds k, we remove the smallest element. By the end of the iteration, the top of the heap represents the kth largest element in the array.

This approach is efficient and avoids unnecessary sorting.

Pseudocode:
- Create a min-heap
- Traverse through each element in the array
- Insert the element into the heap
- If the heap size exceeds k, remove the top element
- After processing all elements, return the top of the heap

Dry Run:

Input:
nums = [3, 2, 1, 5, 6, 4]
k = 2

Step-by-step execution:
- Insert 3 → heap = [3]
- Insert 2 → heap = [2, 3]
- Insert 1 → heap = [1, 3, 2] → size > 2 → remove 1 → heap = [2, 3]
- Insert 5 → heap = [2, 3, 5] → size > 2 → remove 2 → heap = [3, 5]
- Insert 6 → heap = [3, 5, 6] → size > 2 → remove 3 → heap = [5, 6]
- Insert 4 → heap = [4, 6, 5] → size > 2 → remove 4 → heap = [5, 6]

Final heap:
[5, 6]

Top of the heap = 5  
So, the 2nd largest element is **5**.

Time Complexity:
The time complexity is O(n log k), where n is the number of elements in the array. Each insertion and removal from the heap takes O(log k) time.

Space Complexity:
The space complexity is O(k) since the heap stores at most k elements.

This method is efficient, easy to implement, and commonly used in competitive programming and technical interviews.
